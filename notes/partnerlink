partnerlink: better partner retrieval algorithm

we define variables
target partner count M : M % 2 = 0
current partner count Cp

for a new node joining the network, retrieve M / 2 candidate partners and send a Split message to each
each candidate retains Split mapped to uuid and sends TrySplit to random partner
if random partner does not already know new node, returns valid TrySplit, breaks partners with candidate partner and initiates partnership with new node
on receiving valid TrySplit, candidate does the same and returns valid Split
on receiving valid Split, new node initiates partnership with both contained nodes
on invalid TrySplit, the second node returns an invalid Split.

on each buffermap exchange, each node associates its partners into pairs. any node not associated to a partner will be associated to the unassigned transportaddress.
the node associated to each partner is sent along with the buffermap.
if the connection to the central node is failed, or the central node leaves the network cleanly with a Leave message, each partner will initiate a partnership with its association.
the partnership succeeding is assumed, though it may later fail due to timeout as usual.

on receiving an invalid or timed out Split, failing a connection, or terminating a partnership for which the node was associated the unassigned transport address, the node reduces Cp by 1.

if Cp != M and Cp % 2 = 1, we disseminate Panic messages. any panicking node receiving a panic message will contact the node to begin a partnership. the panic message is gossiped amongst nodes via the mCache.
each panic message has a timeout. it is the new node's responsibility to issue a new Panic when the timeout is reached.
this type of message functions best in small networks, as the Panic is very likely to reach the other nodes that were connected to the failed nodes.

if Cp != M and Cp % 2 = 0, we disseminate PanicSplit messages. each node receiving a PanicSplit checks if it is already partners with the contained node. if so, it forwards the packet on with a KNOWN state.
if not, and the message is in KNOWN state, the packet is forwarded with an UNKNOWN state.
if not, and the message is in UNKNOWN state, the Split protocol is initiated and the node returns a TrySplit to the last node in the chain.
this message also has a timeout. it works best in large networks, where many nodes are available that are not aware of the failing node.

any responder to the above will respond via a Recover packet, and immediately initiate a partnership. the panicking node upon receving a Recover will reciprocate.

SplitCall {
	uuid: int // to associate the call to its relevant TrySplit later
	into: TransportAddress
}

SplitResponse {
	result: SUCCESS/FAILED
	first_node: TransportAddress
	second_node: TransportAddress
}

TrySplitCall {
	uuid: int
	into: TransportAddress
	from: TransportAddress
}

TrySplitResponse {
	uuid: int
	result: SUCCESS/FAILED
	into: TransportAddress
	from: TransportAddress
}

BufferMapMsg {
	fallback: TransportAddress
	// ...and whatever else is in BMM
}

Leave {}

Panic {
	panicking: TransportAddress
	ttl: time ?? i don't remember
}

Recover {
	helper: TransportAddress
} // udp response to above or below

PanicSplit {
	state: KNOWN/UNKNOWN
	into: TransportAddress
	from: TransportAddress
}

PanicSplitFound {
	into: TransportAddress
	from: TransportAddress
}
