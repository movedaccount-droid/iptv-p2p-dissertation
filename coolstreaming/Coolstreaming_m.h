//
// Generated file, do not edit! Created by nedtool 5.4 from overlay/coolstreaming/../coolstreaming/Coolstreaming.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __COOLSTREAMING_M_H
#define __COOLSTREAMING_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0504
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <chrono>
#include <set>
#include <unordered_set>
#include "common/NodeHandle.h"
#include "common/OverlayKey.h"
#include "common/CommonMessages_m.h"
#include "common/TransportAddress.h"
typedef std::chrono::duration<int,std::milli> duration_ms;
typedef std::map<TransportAddress, double> BandwidthMap;
typedef std::pair<std::vector<int>, std::map<int, int>> BufferMap;
// }}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:45</tt> by nedtool.
 * <pre>
 * // scamp/mcache membership message
 * packet Membership extends BaseOverlayMessage
 * {
 *     int uuid; // to identify infinitely looping messages
 *     int seq_num;
 *     TransportAddress tad;
 *     int num_partner;
 *     simtime_t ttl;
 *     double bandwidth; // we need this later for scheduler calculations
 *     bool forwarded; // if this was forwarded or is the entry message for the node
 *     bool entry; // if this is the entry message for the node
 * }
 * </pre>
 */
class Membership : public ::BaseOverlayMessage
{
  protected:
    int uuid;
    int seq_num;
    TransportAddress tad;
    int num_partner;
    ::omnetpp::simtime_t ttl;
    double bandwidth;
    bool forwarded;
    bool entry;

  private:
    void copy(const Membership& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Membership&);

  public:
    Membership(const char *name=nullptr, short kind=0);
    Membership(const Membership& other);
    virtual ~Membership();
    Membership& operator=(const Membership& other);
    virtual Membership *dup() const override {return new Membership(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual int getSeq_num() const;
    virtual void setSeq_num(int seq_num);
    virtual TransportAddress& getTad();
    virtual const TransportAddress& getTad() const {return const_cast<Membership*>(this)->getTad();}
    virtual void setTad(const TransportAddress& tad);
    virtual int getNum_partner() const;
    virtual void setNum_partner(int num_partner);
    virtual ::omnetpp::simtime_t getTtl() const;
    virtual void setTtl(::omnetpp::simtime_t ttl);
    virtual double getBandwidth() const;
    virtual void setBandwidth(double bandwidth);
    virtual bool getForwarded() const;
    virtual void setForwarded(bool forwarded);
    virtual bool getEntry() const;
    virtual void setEntry(bool entry);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Membership& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Membership& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:57</tt> by nedtool.
 * <pre>
 * // scamp/inview membership message
 * packet InviewCall extends BaseCallMessage
 * {
 *     TransportAddress destination;
 *     TransportAddress accepting_node;
 * }
 * </pre>
 */
class InviewCall : public ::BaseCallMessage
{
  protected:
    TransportAddress destination;
    TransportAddress accepting_node;

  private:
    void copy(const InviewCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InviewCall&);

  public:
    InviewCall(const char *name=nullptr, short kind=0);
    InviewCall(const InviewCall& other);
    virtual ~InviewCall();
    InviewCall& operator=(const InviewCall& other);
    virtual InviewCall *dup() const override {return new InviewCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDestination();
    virtual const TransportAddress& getDestination() const {return const_cast<InviewCall*>(this)->getDestination();}
    virtual void setDestination(const TransportAddress& destination);
    virtual TransportAddress& getAccepting_node();
    virtual const TransportAddress& getAccepting_node() const {return const_cast<InviewCall*>(this)->getAccepting_node();}
    virtual void setAccepting_node(const TransportAddress& accepting_node);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InviewCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InviewCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:63</tt> by nedtool.
 * <pre>
 * // scamp/inview insertion acknowledgement
 * packet InviewResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class InviewResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const InviewResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InviewResponse&);

  public:
    InviewResponse(const char *name=nullptr, short kind=0);
    InviewResponse(const InviewResponse& other);
    virtual ~InviewResponse();
    InviewResponse& operator=(const InviewResponse& other);
    virtual InviewResponse *dup() const override {return new InviewResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InviewResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InviewResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:66</tt> by nedtool.
 * <pre>
 * // scamp/mcache unsubscription message
 * packet Unsubscription extends BaseOverlayMessage
 * {
 *     TransportAddress leaving;
 *     TransportAddress replacement;
 *     bool inview;
 * }
 * </pre>
 */
class Unsubscription : public ::BaseOverlayMessage
{
  protected:
    TransportAddress leaving;
    TransportAddress replacement;
    bool inview;

  private:
    void copy(const Unsubscription& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Unsubscription&);

  public:
    Unsubscription(const char *name=nullptr, short kind=0);
    Unsubscription(const Unsubscription& other);
    virtual ~Unsubscription();
    Unsubscription& operator=(const Unsubscription& other);
    virtual Unsubscription *dup() const override {return new Unsubscription(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getLeaving();
    virtual const TransportAddress& getLeaving() const {return const_cast<Unsubscription*>(this)->getLeaving();}
    virtual void setLeaving(const TransportAddress& leaving);
    virtual TransportAddress& getReplacement();
    virtual const TransportAddress& getReplacement() const {return const_cast<Unsubscription*>(this)->getReplacement();}
    virtual void setReplacement(const TransportAddress& replacement);
    virtual bool getInview() const;
    virtual void setInview(bool inview);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Unsubscription& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Unsubscription& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:73</tt> by nedtool.
 * <pre>
 * // scamp/mcache heartbeat message
 * packet Heartbeat extends BaseOverlayMessage
 * {
 * }
 * </pre>
 */
class Heartbeat : public ::BaseOverlayMessage
{
  protected:

  private:
    void copy(const Heartbeat& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Heartbeat&);

  public:
    Heartbeat(const char *name=nullptr, short kind=0);
    Heartbeat(const Heartbeat& other);
    virtual ~Heartbeat();
    Heartbeat& operator=(const Heartbeat& other);
    virtual Heartbeat *dup() const override {return new Heartbeat(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Heartbeat& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Heartbeat& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:76</tt> by nedtool.
 * <pre>
 * // coolstreaming origin deputy list request message. no longer contains the starting block index as of new coolstreaming
 * packet GetDeputyCall extends BaseCallMessage
 * {
 *     TransportAddress dest;
 * }
 * </pre>
 */
class GetDeputyCall : public ::BaseCallMessage
{
  protected:
    TransportAddress dest;

  private:
    void copy(const GetDeputyCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetDeputyCall&);

  public:
    GetDeputyCall(const char *name=nullptr, short kind=0);
    GetDeputyCall(const GetDeputyCall& other);
    virtual ~GetDeputyCall();
    GetDeputyCall& operator=(const GetDeputyCall& other);
    virtual GetDeputyCall *dup() const override {return new GetDeputyCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDest();
    virtual const TransportAddress& getDest() const {return const_cast<GetDeputyCall*>(this)->getDest();}
    virtual void setDest(const TransportAddress& dest);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetDeputyCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetDeputyCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:80</tt> by nedtool.
 * <pre>
 * packet GetDeputyResponse extends BaseResponseMessage
 * {
 *     TransportAddress deputy;
 *     int block_index; // to synchronize playout index
 * }
 * </pre>
 */
class GetDeputyResponse : public ::BaseResponseMessage
{
  protected:
    TransportAddress deputy;
    int block_index;

  private:
    void copy(const GetDeputyResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetDeputyResponse&);

  public:
    GetDeputyResponse(const char *name=nullptr, short kind=0);
    GetDeputyResponse(const GetDeputyResponse& other);
    virtual ~GetDeputyResponse();
    GetDeputyResponse& operator=(const GetDeputyResponse& other);
    virtual GetDeputyResponse *dup() const override {return new GetDeputyResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDeputy();
    virtual const TransportAddress& getDeputy() const {return const_cast<GetDeputyResponse*>(this)->getDeputy();}
    virtual void setDeputy(const TransportAddress& deputy);
    virtual int getBlock_index() const;
    virtual void setBlock_index(int block_index);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetDeputyResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetDeputyResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:86</tt> by nedtool.
 * <pre>
 * // coolstreaming deputy partner list request message
 * packet GetCandidatePartnersCall extends BaseCallMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class GetCandidatePartnersCall : public ::BaseCallMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const GetCandidatePartnersCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetCandidatePartnersCall&);

  public:
    GetCandidatePartnersCall(const char *name=nullptr, short kind=0);
    GetCandidatePartnersCall(const GetCandidatePartnersCall& other);
    virtual ~GetCandidatePartnersCall();
    GetCandidatePartnersCall& operator=(const GetCandidatePartnersCall& other);
    virtual GetCandidatePartnersCall *dup() const override {return new GetCandidatePartnersCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<GetCandidatePartnersCall*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetCandidatePartnersCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetCandidatePartnersCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:90</tt> by nedtool.
 * <pre>
 * packet GetCandidatePartnersResponse extends BaseResponseMessage
 * {
 *     BandwidthMap candidates;
 * }
 * 
 * // novel "interlink" algorithm partnership split messages
 * </pre>
 */
class GetCandidatePartnersResponse : public ::BaseResponseMessage
{
  protected:
    BandwidthMap candidates;

  private:
    void copy(const GetCandidatePartnersResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetCandidatePartnersResponse&);

  public:
    GetCandidatePartnersResponse(const char *name=nullptr, short kind=0);
    GetCandidatePartnersResponse(const GetCandidatePartnersResponse& other);
    virtual ~GetCandidatePartnersResponse();
    GetCandidatePartnersResponse& operator=(const GetCandidatePartnersResponse& other);
    virtual GetCandidatePartnersResponse *dup() const override {return new GetCandidatePartnersResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual BandwidthMap& getCandidates();
    virtual const BandwidthMap& getCandidates() const {return const_cast<GetCandidatePartnersResponse*>(this)->getCandidates();}
    virtual void setCandidates(const BandwidthMap& candidates);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetCandidatePartnersResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetCandidatePartnersResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:96</tt> by nedtool.
 * <pre>
 * packet LinkOriginNodes extends BaseOverlayMessage
 * {
 *     TransportAddress origin;
 * }
 * </pre>
 */
class LinkOriginNodes : public ::BaseOverlayMessage
{
  protected:
    TransportAddress origin;

  private:
    void copy(const LinkOriginNodes& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LinkOriginNodes&);

  public:
    LinkOriginNodes(const char *name=nullptr, short kind=0);
    LinkOriginNodes(const LinkOriginNodes& other);
    virtual ~LinkOriginNodes();
    LinkOriginNodes& operator=(const LinkOriginNodes& other);
    virtual LinkOriginNodes *dup() const override {return new LinkOriginNodes(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getOrigin();
    virtual const TransportAddress& getOrigin() const {return const_cast<LinkOriginNodes*>(this)->getOrigin();}
    virtual void setOrigin(const TransportAddress& origin);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LinkOriginNodes& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LinkOriginNodes& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:100</tt> by nedtool.
 * <pre>
 * enum SplitResult
 * {
 *     SUCCESS = 0;
 *     FAILED = 1;
 * }
 * </pre>
 */
enum SplitResult {
    SUCCESS = 0,
    FAILED = 1
};

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:105</tt> by nedtool.
 * <pre>
 * packet SplitCall extends BaseCallMessage
 * {
 *     int uuid; // to associate TrySplit with this SplitCall later
 *     TransportAddress into;
 * }
 * </pre>
 */
class SplitCall : public ::BaseCallMessage
{
  protected:
    int uuid;
    TransportAddress into;

  private:
    void copy(const SplitCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SplitCall&);

  public:
    SplitCall(const char *name=nullptr, short kind=0);
    SplitCall(const SplitCall& other);
    virtual ~SplitCall();
    SplitCall& operator=(const SplitCall& other);
    virtual SplitCall *dup() const override {return new SplitCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual TransportAddress& getInto();
    virtual const TransportAddress& getInto() const {return const_cast<SplitCall*>(this)->getInto();}
    virtual void setInto(const TransportAddress& into);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SplitCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SplitCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:110</tt> by nedtool.
 * <pre>
 * packet SplitResponse extends BaseResponseMessage
 * {
 *     int uuid;
 *     int result \@enum(SplitResult);
 *     TransportAddress first_node;
 *     TransportAddress second_node;
 * }
 * </pre>
 */
class SplitResponse : public ::BaseResponseMessage
{
  protected:
    int uuid;
    int result;
    TransportAddress first_node;
    TransportAddress second_node;

  private:
    void copy(const SplitResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SplitResponse&);

  public:
    SplitResponse(const char *name=nullptr, short kind=0);
    SplitResponse(const SplitResponse& other);
    virtual ~SplitResponse();
    SplitResponse& operator=(const SplitResponse& other);
    virtual SplitResponse *dup() const override {return new SplitResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual int getResult() const;
    virtual void setResult(int result);
    virtual TransportAddress& getFirst_node();
    virtual const TransportAddress& getFirst_node() const {return const_cast<SplitResponse*>(this)->getFirst_node();}
    virtual void setFirst_node(const TransportAddress& first_node);
    virtual TransportAddress& getSecond_node();
    virtual const TransportAddress& getSecond_node() const {return const_cast<SplitResponse*>(this)->getSecond_node();}
    virtual void setSecond_node(const TransportAddress& second_node);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SplitResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SplitResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:117</tt> by nedtool.
 * <pre>
 * packet TrySplitCall extends BaseCallMessage
 * {
 *     int uuid;
 *     TransportAddress into;
 *     TransportAddress from;
 * }
 * </pre>
 */
class TrySplitCall : public ::BaseCallMessage
{
  protected:
    int uuid;
    TransportAddress into;
    TransportAddress from;

  private:
    void copy(const TrySplitCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TrySplitCall&);

  public:
    TrySplitCall(const char *name=nullptr, short kind=0);
    TrySplitCall(const TrySplitCall& other);
    virtual ~TrySplitCall();
    TrySplitCall& operator=(const TrySplitCall& other);
    virtual TrySplitCall *dup() const override {return new TrySplitCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual TransportAddress& getInto();
    virtual const TransportAddress& getInto() const {return const_cast<TrySplitCall*>(this)->getInto();}
    virtual void setInto(const TransportAddress& into);
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<TrySplitCall*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TrySplitCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TrySplitCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:123</tt> by nedtool.
 * <pre>
 * packet TrySplitResponse extends BaseResponseMessage
 * {
 *     int uuid;
 *     int result \@enum(SplitResult);
 *     TransportAddress into;
 *     TransportAddress from;
 * }
 * </pre>
 */
class TrySplitResponse : public ::BaseResponseMessage
{
  protected:
    int uuid;
    int result;
    TransportAddress into;
    TransportAddress from;

  private:
    void copy(const TrySplitResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TrySplitResponse&);

  public:
    TrySplitResponse(const char *name=nullptr, short kind=0);
    TrySplitResponse(const TrySplitResponse& other);
    virtual ~TrySplitResponse();
    TrySplitResponse& operator=(const TrySplitResponse& other);
    virtual TrySplitResponse *dup() const override {return new TrySplitResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual int getResult() const;
    virtual void setResult(int result);
    virtual TransportAddress& getInto();
    virtual const TransportAddress& getInto() const {return const_cast<TrySplitResponse*>(this)->getInto();}
    virtual void setInto(const TransportAddress& into);
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<TrySplitResponse*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TrySplitResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TrySplitResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:130</tt> by nedtool.
 * <pre>
 * packet Leave extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class Leave : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const Leave& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Leave&);

  public:
    Leave(const char *name=nullptr, short kind=0);
    Leave(const Leave& other);
    virtual ~Leave();
    Leave& operator=(const Leave& other);
    virtual Leave *dup() const override {return new Leave(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<Leave*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Leave& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Leave& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:134</tt> by nedtool.
 * <pre>
 * packet PanicMsg extends BaseOverlayMessage
 * {
 *     TransportAddress panicking;
 *     TransportAddress last_hop;
 *     simtime_t send_time;
 * }
 * </pre>
 */
class PanicMsg : public ::BaseOverlayMessage
{
  protected:
    TransportAddress panicking;
    TransportAddress last_hop;
    ::omnetpp::simtime_t send_time;

  private:
    void copy(const PanicMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PanicMsg&);

  public:
    PanicMsg(const char *name=nullptr, short kind=0);
    PanicMsg(const PanicMsg& other);
    virtual ~PanicMsg();
    PanicMsg& operator=(const PanicMsg& other);
    virtual PanicMsg *dup() const override {return new PanicMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getPanicking();
    virtual const TransportAddress& getPanicking() const {return const_cast<PanicMsg*>(this)->getPanicking();}
    virtual void setPanicking(const TransportAddress& panicking);
    virtual TransportAddress& getLast_hop();
    virtual const TransportAddress& getLast_hop() const {return const_cast<PanicMsg*>(this)->getLast_hop();}
    virtual void setLast_hop(const TransportAddress& last_hop);
    virtual ::omnetpp::simtime_t getSend_time() const;
    virtual void setSend_time(::omnetpp::simtime_t send_time);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PanicMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PanicMsg& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:140</tt> by nedtool.
 * <pre>
 * enum LastHopOpinion
 * {
 *     CAN_HELP = 0;
 *     CANT_HELP = 1;
 * }
 * </pre>
 */
enum LastHopOpinion {
    CAN_HELP = 0,
    CANT_HELP = 1
};

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:145</tt> by nedtool.
 * <pre>
 * packet PanicSplitMsg extends BaseOverlayMessage
 * {
 *     int last_hop_opinion \@enum(LastHopOpinion);
 *     TransportAddress panicking;
 *     TransportAddress last_hop;
 *     simtime_t send_time;
 * }
 * </pre>
 */
class PanicSplitMsg : public ::BaseOverlayMessage
{
  protected:
    int last_hop_opinion;
    TransportAddress panicking;
    TransportAddress last_hop;
    ::omnetpp::simtime_t send_time;

  private:
    void copy(const PanicSplitMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PanicSplitMsg&);

  public:
    PanicSplitMsg(const char *name=nullptr, short kind=0);
    PanicSplitMsg(const PanicSplitMsg& other);
    virtual ~PanicSplitMsg();
    PanicSplitMsg& operator=(const PanicSplitMsg& other);
    virtual PanicSplitMsg *dup() const override {return new PanicSplitMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getLast_hop_opinion() const;
    virtual void setLast_hop_opinion(int last_hop_opinion);
    virtual TransportAddress& getPanicking();
    virtual const TransportAddress& getPanicking() const {return const_cast<PanicSplitMsg*>(this)->getPanicking();}
    virtual void setPanicking(const TransportAddress& panicking);
    virtual TransportAddress& getLast_hop();
    virtual const TransportAddress& getLast_hop() const {return const_cast<PanicSplitMsg*>(this)->getLast_hop();}
    virtual void setLast_hop(const TransportAddress& last_hop);
    virtual ::omnetpp::simtime_t getSend_time() const;
    virtual void setSend_time(::omnetpp::simtime_t send_time);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PanicSplitMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PanicSplitMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:152</tt> by nedtool.
 * <pre>
 * packet PanicSplitFound extends BaseOverlayMessage
 * {
 *     TransportAddress panicking;
 *     TransportAddress last_hop;
 * }
 * </pre>
 */
class PanicSplitFound : public ::BaseOverlayMessage
{
  protected:
    TransportAddress panicking;
    TransportAddress last_hop;

  private:
    void copy(const PanicSplitFound& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PanicSplitFound&);

  public:
    PanicSplitFound(const char *name=nullptr, short kind=0);
    PanicSplitFound(const PanicSplitFound& other);
    virtual ~PanicSplitFound();
    PanicSplitFound& operator=(const PanicSplitFound& other);
    virtual PanicSplitFound *dup() const override {return new PanicSplitFound(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getPanicking();
    virtual const TransportAddress& getPanicking() const {return const_cast<PanicSplitFound*>(this)->getPanicking();}
    virtual void setPanicking(const TransportAddress& panicking);
    virtual TransportAddress& getLast_hop();
    virtual const TransportAddress& getLast_hop() const {return const_cast<PanicSplitFound*>(this)->getLast_hop();}
    virtual void setLast_hop(const TransportAddress& last_hop);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PanicSplitFound& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PanicSplitFound& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:157</tt> by nedtool.
 * <pre>
 * packet Recover extends BaseOverlayMessage
 * {
 *     TransportAddress helper;
 * }
 * </pre>
 */
class Recover : public ::BaseOverlayMessage
{
  protected:
    TransportAddress helper;

  private:
    void copy(const Recover& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Recover&);

  public:
    Recover(const char *name=nullptr, short kind=0);
    Recover(const Recover& other);
    virtual ~Recover();
    Recover& operator=(const Recover& other);
    virtual Recover *dup() const override {return new Recover(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getHelper();
    virtual const TransportAddress& getHelper() const {return const_cast<Recover*>(this)->getHelper();}
    virtual void setHelper(const TransportAddress& helper);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Recover& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Recover& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:162</tt> by nedtool.
 * <pre>
 * // self-message to track when to fail a partner connection after not receiving buffermaps for some period
 * message Failure
 * {
 *     TransportAddress failed;
 * }
 * </pre>
 */
class Failure : public ::omnetpp::cMessage
{
  protected:
    TransportAddress failed;

  private:
    void copy(const Failure& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Failure&);

  public:
    Failure(const char *name=nullptr, short kind=0);
    Failure(const Failure& other);
    virtual ~Failure();
    Failure& operator=(const Failure& other);
    virtual Failure *dup() const override {return new Failure(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFailed();
    virtual const TransportAddress& getFailed() const {return const_cast<Failure*>(this)->getFailed();}
    virtual void setFailed(const TransportAddress& failed);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Failure& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Failure& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:167</tt> by nedtool.
 * <pre>
 * // self-message to call when the node's partner network is completely collapsed and we should start over
 * message TotalPartnerFailure
 * {
 * }
 * </pre>
 */
class TotalPartnerFailure : public ::omnetpp::cMessage
{
  protected:

  private:
    void copy(const TotalPartnerFailure& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TotalPartnerFailure&);

  public:
    TotalPartnerFailure(const char *name=nullptr, short kind=0);
    TotalPartnerFailure(const TotalPartnerFailure& other);
    virtual ~TotalPartnerFailure();
    TotalPartnerFailure& operator=(const TotalPartnerFailure& other);
    virtual TotalPartnerFailure *dup() const override {return new TotalPartnerFailure(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TotalPartnerFailure& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TotalPartnerFailure& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:170</tt> by nedtool.
 * <pre>
 * // self-message to disable/enable reselection of a given substream
 * message Cooldown
 * {
 *     int substream;
 * }
 * </pre>
 */
class Cooldown : public ::omnetpp::cMessage
{
  protected:
    int substream;

  private:
    void copy(const Cooldown& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Cooldown&);

  public:
    Cooldown(const char *name=nullptr, short kind=0);
    Cooldown(const Cooldown& other);
    virtual ~Cooldown();
    Cooldown& operator=(const Cooldown& other);
    virtual Cooldown *dup() const override {return new Cooldown(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getSubstream() const;
    virtual void setSubstream(int substream);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Cooldown& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Cooldown& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:175</tt> by nedtool.
 * <pre>
 * // new coolstreaming buffermap exchange, extended with partnerlink data
 * packet BufferMapMsg extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     BufferMap buffer_map;
 *     TransportAddress associate;
 *     bool panicking;
 * }
 * </pre>
 */
class BufferMapMsg : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    BufferMap buffer_map;
    TransportAddress associate;
    bool panicking;

  private:
    void copy(const BufferMapMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BufferMapMsg&);

  public:
    BufferMapMsg(const char *name=nullptr, short kind=0);
    BufferMapMsg(const BufferMapMsg& other);
    virtual ~BufferMapMsg();
    BufferMapMsg& operator=(const BufferMapMsg& other);
    virtual BufferMapMsg *dup() const override {return new BufferMapMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<BufferMapMsg*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual BufferMap& getBuffer_map();
    virtual const BufferMap& getBuffer_map() const {return const_cast<BufferMapMsg*>(this)->getBuffer_map();}
    virtual void setBuffer_map(const BufferMap& buffer_map);
    virtual TransportAddress& getAssociate();
    virtual const TransportAddress& getAssociate() const {return const_cast<BufferMapMsg*>(this)->getAssociate();}
    virtual void setAssociate(const TransportAddress& associate);
    virtual bool getPanicking() const;
    virtual void setPanicking(bool panicking);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BufferMapMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BufferMapMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:183</tt> by nedtool.
 * <pre>
 * // new coolstreaming block push
 * packet Block extends BaseOverlayMessage
 * {
 *     int index;
 *     TransportAddress from;
 * }
 * </pre>
 */
class Block : public ::BaseOverlayMessage
{
  protected:
    int index;
    TransportAddress from;

  private:
    void copy(const Block& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Block&);

  public:
    Block(const char *name=nullptr, short kind=0);
    Block(const Block& other);
    virtual ~Block();
    Block& operator=(const Block& other);
    virtual Block *dup() const override {return new Block(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getIndex() const;
    virtual void setIndex(int index);
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<Block*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Block& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Block& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:189</tt> by nedtool.
 * <pre>
 * // active_node finished downloading self-message/timer
 * message ExchangeAfterDownload
 * {
 *     TransportAddress finished;
 * }
 * </pre>
 */
class ExchangeAfterDownload : public ::omnetpp::cMessage
{
  protected:
    TransportAddress finished;

  private:
    void copy(const ExchangeAfterDownload& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ExchangeAfterDownload&);

  public:
    ExchangeAfterDownload(const char *name=nullptr, short kind=0);
    ExchangeAfterDownload(const ExchangeAfterDownload& other);
    virtual ~ExchangeAfterDownload();
    ExchangeAfterDownload& operator=(const ExchangeAfterDownload& other);
    virtual ExchangeAfterDownload *dup() const override {return new ExchangeAfterDownload(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFinished();
    virtual const TransportAddress& getFinished() const {return const_cast<ExchangeAfterDownload*>(this)->getFinished();}
    virtual void setFinished(const TransportAddress& finished);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ExchangeAfterDownload& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ExchangeAfterDownload& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:194</tt> by nedtool.
 * <pre>
 * // TODO: remove these
 * packet Partnership extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     int bandwidth;
 * }
 * </pre>
 */
class Partnership : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    int bandwidth;

  private:
    void copy(const Partnership& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Partnership&);

  public:
    Partnership(const char *name=nullptr, short kind=0);
    Partnership(const Partnership& other);
    virtual ~Partnership();
    Partnership& operator=(const Partnership& other);
    virtual Partnership *dup() const override {return new Partnership(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<Partnership*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual int getBandwidth() const;
    virtual void setBandwidth(int bandwidth);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Partnership& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Partnership& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:199</tt> by nedtool.
 * <pre>
 * packet PartnershipEnd extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class PartnershipEnd : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const PartnershipEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PartnershipEnd&);

  public:
    PartnershipEnd(const char *name=nullptr, short kind=0);
    PartnershipEnd(const PartnershipEnd& other);
    virtual ~PartnershipEnd();
    PartnershipEnd& operator=(const PartnershipEnd& other);
    virtual PartnershipEnd *dup() const override {return new PartnershipEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<PartnershipEnd*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PartnershipEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PartnershipEnd& obj) {obj.parsimUnpack(b);}


#endif // ifndef __COOLSTREAMING_M_H

