//
// Generated file, do not edit! Created by nedtool 5.4 from overlay/coolstreaming/../coolstreaming/Coolstreaming.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __COOLSTREAMING_M_H
#define __COOLSTREAMING_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0504
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <chrono>
#include <set>
#include <unordered_set>
#include "common/NodeHandle.h"
#include "common/OverlayKey.h"
#include "common/CommonMessages_m.h"
#include "common/TransportAddress.h"
typedef std::chrono::duration<int,std::milli> duration_ms;
typedef std::map<TransportAddress, double> BandwidthMap;
typedef std::unordered_set<int> BM;
// }}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:45</tt> by nedtool.
 * <pre>
 * // scamp/mcache membership message
 * packet Membership extends BaseOverlayMessage
 * {
 *     int uuid; // to identify infinitely looping messages
 *     int seq_num;
 *     TransportAddress tad;
 *     int num_partner;
 *     simtime_t ttl;
 *     double bandwidth; // we need this later for scheduler calculations
 *     bool forwarded; // if this was forwarded or is the entry message for the node
 *     bool entry; // if this is the entry message for the node
 * }
 * </pre>
 */
class Membership : public ::BaseOverlayMessage
{
  protected:
    int uuid;
    int seq_num;
    TransportAddress tad;
    int num_partner;
    ::omnetpp::simtime_t ttl;
    double bandwidth;
    bool forwarded;
    bool entry;

  private:
    void copy(const Membership& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Membership&);

  public:
    Membership(const char *name=nullptr, short kind=0);
    Membership(const Membership& other);
    virtual ~Membership();
    Membership& operator=(const Membership& other);
    virtual Membership *dup() const override {return new Membership(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual int getSeq_num() const;
    virtual void setSeq_num(int seq_num);
    virtual TransportAddress& getTad();
    virtual const TransportAddress& getTad() const {return const_cast<Membership*>(this)->getTad();}
    virtual void setTad(const TransportAddress& tad);
    virtual int getNum_partner() const;
    virtual void setNum_partner(int num_partner);
    virtual ::omnetpp::simtime_t getTtl() const;
    virtual void setTtl(::omnetpp::simtime_t ttl);
    virtual double getBandwidth() const;
    virtual void setBandwidth(double bandwidth);
    virtual bool getForwarded() const;
    virtual void setForwarded(bool forwarded);
    virtual bool getEntry() const;
    virtual void setEntry(bool entry);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Membership& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Membership& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:57</tt> by nedtool.
 * <pre>
 * // scamp/inview membership message
 * packet InviewCall extends BaseCallMessage
 * {
 *     TransportAddress destination;
 *     TransportAddress accepting_node;
 * }
 * </pre>
 */
class InviewCall : public ::BaseCallMessage
{
  protected:
    TransportAddress destination;
    TransportAddress accepting_node;

  private:
    void copy(const InviewCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InviewCall&);

  public:
    InviewCall(const char *name=nullptr, short kind=0);
    InviewCall(const InviewCall& other);
    virtual ~InviewCall();
    InviewCall& operator=(const InviewCall& other);
    virtual InviewCall *dup() const override {return new InviewCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDestination();
    virtual const TransportAddress& getDestination() const {return const_cast<InviewCall*>(this)->getDestination();}
    virtual void setDestination(const TransportAddress& destination);
    virtual TransportAddress& getAccepting_node();
    virtual const TransportAddress& getAccepting_node() const {return const_cast<InviewCall*>(this)->getAccepting_node();}
    virtual void setAccepting_node(const TransportAddress& accepting_node);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InviewCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InviewCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:63</tt> by nedtool.
 * <pre>
 * // scamp/inview insertion acknowledgement
 * packet InviewResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class InviewResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const InviewResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InviewResponse&);

  public:
    InviewResponse(const char *name=nullptr, short kind=0);
    InviewResponse(const InviewResponse& other);
    virtual ~InviewResponse();
    InviewResponse& operator=(const InviewResponse& other);
    virtual InviewResponse *dup() const override {return new InviewResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InviewResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InviewResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:66</tt> by nedtool.
 * <pre>
 * // scamp/mcache unsubscription message
 * packet Unsubscription extends BaseOverlayMessage
 * {
 *     TransportAddress leaving;
 *     TransportAddress replacement;
 *     bool inview;
 * }
 * </pre>
 */
class Unsubscription : public ::BaseOverlayMessage
{
  protected:
    TransportAddress leaving;
    TransportAddress replacement;
    bool inview;

  private:
    void copy(const Unsubscription& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Unsubscription&);

  public:
    Unsubscription(const char *name=nullptr, short kind=0);
    Unsubscription(const Unsubscription& other);
    virtual ~Unsubscription();
    Unsubscription& operator=(const Unsubscription& other);
    virtual Unsubscription *dup() const override {return new Unsubscription(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getLeaving();
    virtual const TransportAddress& getLeaving() const {return const_cast<Unsubscription*>(this)->getLeaving();}
    virtual void setLeaving(const TransportAddress& leaving);
    virtual TransportAddress& getReplacement();
    virtual const TransportAddress& getReplacement() const {return const_cast<Unsubscription*>(this)->getReplacement();}
    virtual void setReplacement(const TransportAddress& replacement);
    virtual bool getInview() const;
    virtual void setInview(bool inview);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Unsubscription& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Unsubscription& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:74</tt> by nedtool.
 * <pre>
 * // coolstreaming-extended scamp gossiped unsubscription message .
 * // i feel the need to again mentino that this is a Very Fucking Bad Idea
 * packet GossipedUnsubscription extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     TransportAddress failing;
 * }
 * </pre>
 */
class GossipedUnsubscription : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    TransportAddress failing;

  private:
    void copy(const GossipedUnsubscription& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GossipedUnsubscription&);

  public:
    GossipedUnsubscription(const char *name=nullptr, short kind=0);
    GossipedUnsubscription(const GossipedUnsubscription& other);
    virtual ~GossipedUnsubscription();
    GossipedUnsubscription& operator=(const GossipedUnsubscription& other);
    virtual GossipedUnsubscription *dup() const override {return new GossipedUnsubscription(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<GossipedUnsubscription*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual TransportAddress& getFailing();
    virtual const TransportAddress& getFailing() const {return const_cast<GossipedUnsubscription*>(this)->getFailing();}
    virtual void setFailing(const TransportAddress& failing);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GossipedUnsubscription& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GossipedUnsubscription& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:80</tt> by nedtool.
 * <pre>
 * // scamp/mcache heartbeat message
 * packet Heartbeat extends BaseOverlayMessage
 * {
 * }
 * </pre>
 */
class Heartbeat : public ::BaseOverlayMessage
{
  protected:

  private:
    void copy(const Heartbeat& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Heartbeat&);

  public:
    Heartbeat(const char *name=nullptr, short kind=0);
    Heartbeat(const Heartbeat& other);
    virtual ~Heartbeat();
    Heartbeat& operator=(const Heartbeat& other);
    virtual Heartbeat *dup() const override {return new Heartbeat(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Heartbeat& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Heartbeat& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:83</tt> by nedtool.
 * <pre>
 * // coolstreaming origin deputy list request message. also contains the starting block index
 * packet GetDeputyCall extends BaseCallMessage
 * {
 *     TransportAddress dest;
 * }
 * </pre>
 */
class GetDeputyCall : public ::BaseCallMessage
{
  protected:
    TransportAddress dest;

  private:
    void copy(const GetDeputyCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetDeputyCall&);

  public:
    GetDeputyCall(const char *name=nullptr, short kind=0);
    GetDeputyCall(const GetDeputyCall& other);
    virtual ~GetDeputyCall();
    GetDeputyCall& operator=(const GetDeputyCall& other);
    virtual GetDeputyCall *dup() const override {return new GetDeputyCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDest();
    virtual const TransportAddress& getDest() const {return const_cast<GetDeputyCall*>(this)->getDest();}
    virtual void setDest(const TransportAddress& dest);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetDeputyCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetDeputyCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:87</tt> by nedtool.
 * <pre>
 * packet GetDeputyResponse extends BaseResponseMessage
 * {
 *     TransportAddress deputy;
 *     int block_index;
 * }
 * </pre>
 */
class GetDeputyResponse : public ::BaseResponseMessage
{
  protected:
    TransportAddress deputy;
    int block_index;

  private:
    void copy(const GetDeputyResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetDeputyResponse&);

  public:
    GetDeputyResponse(const char *name=nullptr, short kind=0);
    GetDeputyResponse(const GetDeputyResponse& other);
    virtual ~GetDeputyResponse();
    GetDeputyResponse& operator=(const GetDeputyResponse& other);
    virtual GetDeputyResponse *dup() const override {return new GetDeputyResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDeputy();
    virtual const TransportAddress& getDeputy() const {return const_cast<GetDeputyResponse*>(this)->getDeputy();}
    virtual void setDeputy(const TransportAddress& deputy);
    virtual int getBlock_index() const;
    virtual void setBlock_index(int block_index);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetDeputyResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetDeputyResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:93</tt> by nedtool.
 * <pre>
 * // coolstreaming deputy partner list request message
 * packet GetCandidatePartnersCall extends BaseCallMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class GetCandidatePartnersCall : public ::BaseCallMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const GetCandidatePartnersCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetCandidatePartnersCall&);

  public:
    GetCandidatePartnersCall(const char *name=nullptr, short kind=0);
    GetCandidatePartnersCall(const GetCandidatePartnersCall& other);
    virtual ~GetCandidatePartnersCall();
    GetCandidatePartnersCall& operator=(const GetCandidatePartnersCall& other);
    virtual GetCandidatePartnersCall *dup() const override {return new GetCandidatePartnersCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<GetCandidatePartnersCall*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetCandidatePartnersCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetCandidatePartnersCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:97</tt> by nedtool.
 * <pre>
 * packet GetCandidatePartnersResponse extends BaseResponseMessage
 * {
 *     BandwidthMap candidates;
 * }
 * </pre>
 */
class GetCandidatePartnersResponse : public ::BaseResponseMessage
{
  protected:
    BandwidthMap candidates;

  private:
    void copy(const GetCandidatePartnersResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetCandidatePartnersResponse&);

  public:
    GetCandidatePartnersResponse(const char *name=nullptr, short kind=0);
    GetCandidatePartnersResponse(const GetCandidatePartnersResponse& other);
    virtual ~GetCandidatePartnersResponse();
    GetCandidatePartnersResponse& operator=(const GetCandidatePartnersResponse& other);
    virtual GetCandidatePartnersResponse *dup() const override {return new GetCandidatePartnersResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual BandwidthMap& getCandidates();
    virtual const BandwidthMap& getCandidates() const {return const_cast<GetCandidatePartnersResponse*>(this)->getCandidates();}
    virtual void setCandidates(const BandwidthMap& candidates);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetCandidatePartnersResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetCandidatePartnersResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:102</tt> by nedtool.
 * <pre>
 * // coolstreaming partnership initiation/ending
 * packet Partnership extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     double bandwidth;
 * }
 * </pre>
 */
class Partnership : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    double bandwidth;

  private:
    void copy(const Partnership& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Partnership&);

  public:
    Partnership(const char *name=nullptr, short kind=0);
    Partnership(const Partnership& other);
    virtual ~Partnership();
    Partnership& operator=(const Partnership& other);
    virtual Partnership *dup() const override {return new Partnership(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<Partnership*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual double getBandwidth() const;
    virtual void setBandwidth(double bandwidth);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Partnership& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Partnership& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:107</tt> by nedtool.
 * <pre>
 * packet PartnershipEnd extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class PartnershipEnd : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const PartnershipEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PartnershipEnd&);

  public:
    PartnershipEnd(const char *name=nullptr, short kind=0);
    PartnershipEnd(const PartnershipEnd& other);
    virtual ~PartnershipEnd();
    PartnershipEnd& operator=(const PartnershipEnd& other);
    virtual PartnershipEnd *dup() const override {return new PartnershipEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<PartnershipEnd*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PartnershipEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PartnershipEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:112</tt> by nedtool.
 * <pre>
 * // coolstreaming buffermap exchange
 * packet BufferMap extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     BM buffer_map;
 * }
 * </pre>
 */
class BufferMap : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    BM buffer_map;

  private:
    void copy(const BufferMap& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BufferMap&);

  public:
    BufferMap(const char *name=nullptr, short kind=0);
    BufferMap(const BufferMap& other);
    virtual ~BufferMap();
    BufferMap& operator=(const BufferMap& other);
    virtual BufferMap *dup() const override {return new BufferMap(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<BufferMap*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual BM& getBuffer_map();
    virtual const BM& getBuffer_map() const {return const_cast<BufferMap*>(this)->getBuffer_map();}
    virtual void setBuffer_map(const BM& buffer_map);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BufferMap& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BufferMap& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:118</tt> by nedtool.
 * <pre>
 * // coolstreaming block request
 * packet BlockRequest extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     BM blocks;
 * }
 * </pre>
 */
class BlockRequest : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    BM blocks;

  private:
    void copy(const BlockRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BlockRequest&);

  public:
    BlockRequest(const char *name=nullptr, short kind=0);
    BlockRequest(const BlockRequest& other);
    virtual ~BlockRequest();
    BlockRequest& operator=(const BlockRequest& other);
    virtual BlockRequest *dup() const override {return new BlockRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<BlockRequest*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual BM& getBlocks();
    virtual const BM& getBlocks() const {return const_cast<BlockRequest*>(this)->getBlocks();}
    virtual void setBlocks(const BM& blocks);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BlockRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BlockRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:123</tt> by nedtool.
 * <pre>
 * packet Block extends BaseOverlayMessage
 * {
 *     int index;
 * }
 * </pre>
 */
class Block : public ::BaseOverlayMessage
{
  protected:
    int index;

  private:
    void copy(const Block& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Block&);

  public:
    Block(const char *name=nullptr, short kind=0);
    Block(const Block& other);
    virtual ~Block();
    Block& operator=(const Block& other);
    virtual Block *dup() const override {return new Block(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getIndex() const;
    virtual void setIndex(int index);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Block& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Block& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:128</tt> by nedtool.
 * <pre>
 * // active_node finished downloading self-message/timer
 * message ExchangeAfterDownload
 * {
 *     TransportAddress finished;
 * }
 * </pre>
 */
class ExchangeAfterDownload : public ::omnetpp::cMessage
{
  protected:
    TransportAddress finished;

  private:
    void copy(const ExchangeAfterDownload& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ExchangeAfterDownload&);

  public:
    ExchangeAfterDownload(const char *name=nullptr, short kind=0);
    ExchangeAfterDownload(const ExchangeAfterDownload& other);
    virtual ~ExchangeAfterDownload();
    ExchangeAfterDownload& operator=(const ExchangeAfterDownload& other);
    virtual ExchangeAfterDownload *dup() const override {return new ExchangeAfterDownload(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFinished();
    virtual const TransportAddress& getFinished() const {return const_cast<ExchangeAfterDownload*>(this)->getFinished();}
    virtual void setFinished(const TransportAddress& finished);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ExchangeAfterDownload& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ExchangeAfterDownload& obj) {obj.parsimUnpack(b);}


#endif // ifndef __COOLSTREAMING_M_H

