//
// Generated file, do not edit! Created by nedtool 5.4 from overlay/coolstreaming/../coolstreaming/Coolstreaming.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __COOLSTREAMING_M_H
#define __COOLSTREAMING_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0504
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <chrono>
#include <set>
#include <unordered_set>
#include "common/NodeHandle.h"
#include "common/OverlayKey.h"
#include "common/CommonMessages_m.h"
#include "common/TransportAddress.h"
typedef std::chrono::duration<int,std::milli> duration_ms;
typedef std::map<TransportAddress, double> BandwidthMap;
typedef std::pair<std::vector<int>, std::map<int, int>> BufferMap;
// }}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:45</tt> by nedtool.
 * <pre>
 * // scamp/mcache membership message
 * packet Membership extends BaseOverlayMessage
 * {
 *     int uuid; // to identify infinitely looping messages
 *     int seq_num;
 *     TransportAddress tad;
 *     int num_partner;
 *     simtime_t ttl;
 *     double bandwidth; // we need this later for scheduler calculations
 *     bool forwarded; // if this was forwarded or is the entry message for the node
 *     bool entry; // if this is the entry message for the node
 * }
 * </pre>
 */
class Membership : public ::BaseOverlayMessage
{
  protected:
    int uuid;
    int seq_num;
    TransportAddress tad;
    int num_partner;
    ::omnetpp::simtime_t ttl;
    double bandwidth;
    bool forwarded;
    bool entry;

  private:
    void copy(const Membership& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Membership&);

  public:
    Membership(const char *name=nullptr, short kind=0);
    Membership(const Membership& other);
    virtual ~Membership();
    Membership& operator=(const Membership& other);
    virtual Membership *dup() const override {return new Membership(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getUuid() const;
    virtual void setUuid(int uuid);
    virtual int getSeq_num() const;
    virtual void setSeq_num(int seq_num);
    virtual TransportAddress& getTad();
    virtual const TransportAddress& getTad() const {return const_cast<Membership*>(this)->getTad();}
    virtual void setTad(const TransportAddress& tad);
    virtual int getNum_partner() const;
    virtual void setNum_partner(int num_partner);
    virtual ::omnetpp::simtime_t getTtl() const;
    virtual void setTtl(::omnetpp::simtime_t ttl);
    virtual double getBandwidth() const;
    virtual void setBandwidth(double bandwidth);
    virtual bool getForwarded() const;
    virtual void setForwarded(bool forwarded);
    virtual bool getEntry() const;
    virtual void setEntry(bool entry);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Membership& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Membership& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:57</tt> by nedtool.
 * <pre>
 * // scamp/inview membership message
 * packet InviewCall extends BaseCallMessage
 * {
 *     TransportAddress destination;
 *     TransportAddress accepting_node;
 * }
 * </pre>
 */
class InviewCall : public ::BaseCallMessage
{
  protected:
    TransportAddress destination;
    TransportAddress accepting_node;

  private:
    void copy(const InviewCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InviewCall&);

  public:
    InviewCall(const char *name=nullptr, short kind=0);
    InviewCall(const InviewCall& other);
    virtual ~InviewCall();
    InviewCall& operator=(const InviewCall& other);
    virtual InviewCall *dup() const override {return new InviewCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDestination();
    virtual const TransportAddress& getDestination() const {return const_cast<InviewCall*>(this)->getDestination();}
    virtual void setDestination(const TransportAddress& destination);
    virtual TransportAddress& getAccepting_node();
    virtual const TransportAddress& getAccepting_node() const {return const_cast<InviewCall*>(this)->getAccepting_node();}
    virtual void setAccepting_node(const TransportAddress& accepting_node);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InviewCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InviewCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:63</tt> by nedtool.
 * <pre>
 * // scamp/inview insertion acknowledgement
 * packet InviewResponse extends BaseResponseMessage
 * {
 * }
 * </pre>
 */
class InviewResponse : public ::BaseResponseMessage
{
  protected:

  private:
    void copy(const InviewResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InviewResponse&);

  public:
    InviewResponse(const char *name=nullptr, short kind=0);
    InviewResponse(const InviewResponse& other);
    virtual ~InviewResponse();
    InviewResponse& operator=(const InviewResponse& other);
    virtual InviewResponse *dup() const override {return new InviewResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InviewResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InviewResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:66</tt> by nedtool.
 * <pre>
 * // scamp/mcache unsubscription message
 * packet Unsubscription extends BaseOverlayMessage
 * {
 *     TransportAddress leaving;
 *     TransportAddress replacement;
 *     bool inview;
 * }
 * </pre>
 */
class Unsubscription : public ::BaseOverlayMessage
{
  protected:
    TransportAddress leaving;
    TransportAddress replacement;
    bool inview;

  private:
    void copy(const Unsubscription& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Unsubscription&);

  public:
    Unsubscription(const char *name=nullptr, short kind=0);
    Unsubscription(const Unsubscription& other);
    virtual ~Unsubscription();
    Unsubscription& operator=(const Unsubscription& other);
    virtual Unsubscription *dup() const override {return new Unsubscription(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getLeaving();
    virtual const TransportAddress& getLeaving() const {return const_cast<Unsubscription*>(this)->getLeaving();}
    virtual void setLeaving(const TransportAddress& leaving);
    virtual TransportAddress& getReplacement();
    virtual const TransportAddress& getReplacement() const {return const_cast<Unsubscription*>(this)->getReplacement();}
    virtual void setReplacement(const TransportAddress& replacement);
    virtual bool getInview() const;
    virtual void setInview(bool inview);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Unsubscription& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Unsubscription& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:73</tt> by nedtool.
 * <pre>
 * // scamp/mcache heartbeat message
 * packet Heartbeat extends BaseOverlayMessage
 * {
 * }
 * </pre>
 */
class Heartbeat : public ::BaseOverlayMessage
{
  protected:

  private:
    void copy(const Heartbeat& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Heartbeat&);

  public:
    Heartbeat(const char *name=nullptr, short kind=0);
    Heartbeat(const Heartbeat& other);
    virtual ~Heartbeat();
    Heartbeat& operator=(const Heartbeat& other);
    virtual Heartbeat *dup() const override {return new Heartbeat(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Heartbeat& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Heartbeat& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:76</tt> by nedtool.
 * <pre>
 * // coolstreaming origin deputy list request message. no longer contains the starting block index as of new coolstreaming
 * packet GetDeputyCall extends BaseCallMessage
 * {
 *     TransportAddress dest;
 * }
 * </pre>
 */
class GetDeputyCall : public ::BaseCallMessage
{
  protected:
    TransportAddress dest;

  private:
    void copy(const GetDeputyCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetDeputyCall&);

  public:
    GetDeputyCall(const char *name=nullptr, short kind=0);
    GetDeputyCall(const GetDeputyCall& other);
    virtual ~GetDeputyCall();
    GetDeputyCall& operator=(const GetDeputyCall& other);
    virtual GetDeputyCall *dup() const override {return new GetDeputyCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDest();
    virtual const TransportAddress& getDest() const {return const_cast<GetDeputyCall*>(this)->getDest();}
    virtual void setDest(const TransportAddress& dest);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetDeputyCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetDeputyCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:80</tt> by nedtool.
 * <pre>
 * packet GetDeputyResponse extends BaseResponseMessage
 * {
 *     TransportAddress deputy;
 * }
 * </pre>
 */
class GetDeputyResponse : public ::BaseResponseMessage
{
  protected:
    TransportAddress deputy;

  private:
    void copy(const GetDeputyResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetDeputyResponse&);

  public:
    GetDeputyResponse(const char *name=nullptr, short kind=0);
    GetDeputyResponse(const GetDeputyResponse& other);
    virtual ~GetDeputyResponse();
    GetDeputyResponse& operator=(const GetDeputyResponse& other);
    virtual GetDeputyResponse *dup() const override {return new GetDeputyResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getDeputy();
    virtual const TransportAddress& getDeputy() const {return const_cast<GetDeputyResponse*>(this)->getDeputy();}
    virtual void setDeputy(const TransportAddress& deputy);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetDeputyResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetDeputyResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:85</tt> by nedtool.
 * <pre>
 * // coolstreaming deputy partner list request message
 * packet GetCandidatePartnersCall extends BaseCallMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class GetCandidatePartnersCall : public ::BaseCallMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const GetCandidatePartnersCall& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetCandidatePartnersCall&);

  public:
    GetCandidatePartnersCall(const char *name=nullptr, short kind=0);
    GetCandidatePartnersCall(const GetCandidatePartnersCall& other);
    virtual ~GetCandidatePartnersCall();
    GetCandidatePartnersCall& operator=(const GetCandidatePartnersCall& other);
    virtual GetCandidatePartnersCall *dup() const override {return new GetCandidatePartnersCall(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<GetCandidatePartnersCall*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetCandidatePartnersCall& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetCandidatePartnersCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:89</tt> by nedtool.
 * <pre>
 * packet GetCandidatePartnersResponse extends BaseResponseMessage
 * {
 *     BandwidthMap candidates;
 * }
 * </pre>
 */
class GetCandidatePartnersResponse : public ::BaseResponseMessage
{
  protected:
    BandwidthMap candidates;

  private:
    void copy(const GetCandidatePartnersResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetCandidatePartnersResponse&);

  public:
    GetCandidatePartnersResponse(const char *name=nullptr, short kind=0);
    GetCandidatePartnersResponse(const GetCandidatePartnersResponse& other);
    virtual ~GetCandidatePartnersResponse();
    GetCandidatePartnersResponse& operator=(const GetCandidatePartnersResponse& other);
    virtual GetCandidatePartnersResponse *dup() const override {return new GetCandidatePartnersResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual BandwidthMap& getCandidates();
    virtual const BandwidthMap& getCandidates() const {return const_cast<GetCandidatePartnersResponse*>(this)->getCandidates();}
    virtual void setCandidates(const BandwidthMap& candidates);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GetCandidatePartnersResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GetCandidatePartnersResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:94</tt> by nedtool.
 * <pre>
 * // coolstreaming partnership initiation/ending
 * packet Partnership extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     double bandwidth;
 * }
 * </pre>
 */
class Partnership : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    double bandwidth;

  private:
    void copy(const Partnership& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Partnership&);

  public:
    Partnership(const char *name=nullptr, short kind=0);
    Partnership(const Partnership& other);
    virtual ~Partnership();
    Partnership& operator=(const Partnership& other);
    virtual Partnership *dup() const override {return new Partnership(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<Partnership*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual double getBandwidth() const;
    virtual void setBandwidth(double bandwidth);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Partnership& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Partnership& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:99</tt> by nedtool.
 * <pre>
 * packet PartnershipEnd extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 * }
 * </pre>
 */
class PartnershipEnd : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;

  private:
    void copy(const PartnershipEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PartnershipEnd&);

  public:
    PartnershipEnd(const char *name=nullptr, short kind=0);
    PartnershipEnd(const PartnershipEnd& other);
    virtual ~PartnershipEnd();
    PartnershipEnd& operator=(const PartnershipEnd& other);
    virtual PartnershipEnd *dup() const override {return new PartnershipEnd(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<PartnershipEnd*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PartnershipEnd& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PartnershipEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:104</tt> by nedtool.
 * <pre>
 * // new coolstreaming buffermap exchange
 * packet BufferMapMsg extends BaseOverlayMessage
 * {
 *     TransportAddress from;
 *     BufferMap buffer_map;
 * }
 * </pre>
 */
class BufferMapMsg : public ::BaseOverlayMessage
{
  protected:
    TransportAddress from;
    BufferMap buffer_map;

  private:
    void copy(const BufferMapMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BufferMapMsg&);

  public:
    BufferMapMsg(const char *name=nullptr, short kind=0);
    BufferMapMsg(const BufferMapMsg& other);
    virtual ~BufferMapMsg();
    BufferMapMsg& operator=(const BufferMapMsg& other);
    virtual BufferMapMsg *dup() const override {return new BufferMapMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual TransportAddress& getFrom();
    virtual const TransportAddress& getFrom() const {return const_cast<BufferMapMsg*>(this)->getFrom();}
    virtual void setFrom(const TransportAddress& from);
    virtual BufferMap& getBuffer_map();
    virtual const BufferMap& getBuffer_map() const {return const_cast<BufferMapMsg*>(this)->getBuffer_map();}
    virtual void setBuffer_map(const BufferMap& buffer_map);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BufferMapMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BufferMapMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>overlay/coolstreaming/../coolstreaming/Coolstreaming.msg:112</tt> by nedtool.
 * <pre>
 * // new coolstreaming block push
 * // when we send two blocks to catch up a node, that block would send four blocks in turn, eight, sixteen etc.
 * // to avoid this we only allow the second block to trigger forwarding; the following node thus only sends two blocks
 * packet Block extends BaseOverlayMessage
 * {
 *     int index;
 *     bool triggers_send;
 * }
 * </pre>
 */
class Block : public ::BaseOverlayMessage
{
  protected:
    int index;
    bool triggers_send;

  private:
    void copy(const Block& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Block&);

  public:
    Block(const char *name=nullptr, short kind=0);
    Block(const Block& other);
    virtual ~Block();
    Block& operator=(const Block& other);
    virtual Block *dup() const override {return new Block(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getIndex() const;
    virtual void setIndex(int index);
    virtual bool getTriggers_send() const;
    virtual void setTriggers_send(bool triggers_send);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Block& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Block& obj) {obj.parsimUnpack(b);}


#endif // ifndef __COOLSTREAMING_M_H

